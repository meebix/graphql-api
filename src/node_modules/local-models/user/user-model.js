const shortId = require('shortid');
const argon2 = require('argon2');
const md5 = require('md5');
const generateCode = require('local-generate-code');
const addMinutes = require('date-fns/add_minutes');
const userValidations = require('./user-validations');
const userFormatters = require('./user-formatters');
const config = require('config');
const BaseModel = require('../base/base-model');

class User extends BaseModel {
  constructor() {
    super();

    this.name = 'user';
    this.argon2 = argon2;
    this.validations = userValidations;
    this.formatters = userFormatters;
  }

  /**
   * Create a new user
   *
   * @param {Object} attributes - A set of user attributes to create the user with
   * @return {Object} The newly created user object
   */
  async create(attributes) {
    console.log('XX', attributes);
    const uid = shortId.generate();
    const role = await this._getRole('user');
    const { hashedPassword } = await this.hashPassword(null, attributes.password);

    const payload = Object.assign({}, attributes, {
      uid,
      role_id: role.id,
      password: hashedPassword,
      confirmed: false,
      confirmed_token: md5(attributes.email + Math.random()),
      confirmed_expires: addMinutes(new Date(), config.auth.tokens.confirmed.expireTime),
    });

    return this.validate(attributes)
      .then(() => this.format(payload)
        .then(formattedValues =>
          this
            .knex('users')
            .insert(formattedValues)
            .then(() =>
              this.knex('users')
                .where({ uid })
                .first())));
  }

  /**
   * Hash the password
   *
   * @param {Object} instance - A user model instance
   * @param {Object} attributes - A set of user attributes to be updated
   * @param {Array} fieldsToValidate - A whitelist of fields to validate against
   * @return {Object} A user instance with the updated values
   */
  update(instance, attributes, fieldsToValidate) {
    return this.validate(fieldsToValidate || attributes)
      .then(() => this.format(attributes)
        .then(formattedValues =>
          this
            .knex('users')
            .where({ uid: instance.uid })
            .update(formattedValues)
            .then(() =>
              this.knex('users')
                .where({ uid: instance.uid })
                .first())
            .then(updatedUser => Object.assign({}, instance, updatedUser))));
  }

  /**
   * Hash a password
   *
   * @param {Object} instance - A user model instance
   * @param {String} password - The user's password
   * @return {Object} The hashed password and the original user instance
   */
  hashPassword(instance, password) {
    return this.argon2.hash(password, { timeCost: 2000, memoryCost: 500 })
      .then(hashedPassword => ({ hashedPassword, user: instance }));
  }

  /**
   * Compare passwords and if no match, checks for locked account
   *
   * @param {Object} instance - A user model instance
   * @param {String} password - The user's password
   * @return {Object} A boolean for if there is a match and the original user instance
   */
  async comparePassword(instance, password) {
    const user = await this.knex('users').where({ uid: instance.uid }).first().select('password');

    return this.argon2.verify(user.password, password)
      .then(isMatch => ({ isMatch, user: instance }));
  }

  /**
   * Determines if an account has been locked due to failed login attempts
   * or failed security question attempts
   *
   * @param {Object} instance - A user model instance
   * @return {Object} If the account is locked and the user {locked, user}
   */
  checkForLockedAccount(instance) {
    if (config.auth.lockable === false) return { locked: false, user: null };
    if (instance.account_locked) return { locked: true, user: null };

    if (
      instance.login_attempts === config.auth.lockable.maxAttempts ||
      instance.question_attempts === config.auth.lockable.maxAttempts
    ) {
      return this
        .knex('users')
        .where({ uid: instance.uid })
        .update({
          account_locked: true,
          unlock_account_code: generateCode(),
          unlock_account_expires: addMinutes(
            new Date(),
            config.auth.tokens.unlockAccount.expireTime,
          ),
        })
        .then(() =>
          this
            .knex('users')
            .where({ uid: instance.uid })
            .first()
            .then(lockedAccount => ({ locked: true, user: lockedAccount })));
    }

    return { locked: false, user: instance };
  }

  /**
   * Gets the Role ID for the given role
   *
   * @param {String} role - The name of a role
   * @return {String} A role ID.
   */
  _getRole(role) {
    return this.knex('roles').where('role', role).first().select('id');
  }
}

module.exports = User;
