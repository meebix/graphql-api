const shortId = require('shortid');
const bcrypt = require('bcrypt');
const argon2 = require('argon2');
const md5 = require('md5');
const validator = require('local-validator');
const addMinutes = require('date-fns/add_minutes');
const userValidations = require('./user-validations');
const userFormatters = require('./user-formatters');
const config = require('config');
const knex = require('knex')(config.database);

class User {
  constructor() {
    this.name = 'user';
    this.orm = knex;
    this.bcrypt = bcrypt;
    this.argon2 = argon2;
    this.validations = userValidations;
    this.formatters = userFormatters;
  }

  /**
   * Create ORM query connection to a given database model
   *
   * @param {String} model - Database table model to query; Default: 'users'
   * @return {Object} Query instance
   */
  knex(model = 'users') {
    return this.orm(model);
  }

  /**
   * Create a new user
   *
   * @param {Object} attributes - A set of user attributes to create the user with
   * @return {Object} The newly created user object
   */
  async create(attributes) {
    const uid = shortId.generate();
    const role = await this._getRole('user');
    const { hashedPassword } = await this.hashPassword(null, attributes.password);

    const payload = Object.assign({}, attributes, {
      uid,
      role_id: role.id,
      password: hashedPassword,
      confirmed: false,
      confirmed_token: md5(attributes.email + Math.random()),
      confirmed_expires: addMinutes(new Date(), config.auth.tokens.confirmed.expireTime),
    });

    return this.validate(attributes)
      .then(() => this.format(payload)
        .then(formattedValues =>
          this
            .knex()
            .insert(formattedValues)
            .then(() =>
              this.knex()
                .where({ uid })
                .first())));
  }

  /**
   * Hash the password
   *
   * @param {Object} instance - A user model instance
   * @param {Object} attributes - A set of user attributes to be updated
   * @param {Array} fieldsToValidate - A whitelist of fields to validate against
   * @return {Object} A user instance with the updated values
   */
  update(instance, attributes, fieldsToValidate) {
    return this.validate(fieldsToValidate || attributes)
      .then(() => this.format(attributes)
        .then(formattedValues =>
          this
            .knex()
            .where({ uid: instance.uid })
            .update(formattedValues)
            .then(() =>
              this.knex()
                .where({ uid: instance.uid })
                .first())
            .then(updatedUser => Object.assign({}, instance, updatedUser))));
  }

  /**
   * Hash a password
   *
   * @param {Object} instance - A user model instance
   * @param {String} password - The user's password
   * @return {Object} The hashed password and the original user instance
   */
  hashPassword(instance, password) {
    return this.argon2.hash(password, { timeCost: 2000, memoryCost: 500 })
      .then(hashedPassword => ({ hashedPassword, user: instance }));
  }

  /**
   * Compare passwords and if no match, checks for locked account
   *
   * @param {Object} instance - A user model instance
   * @param {String} password - The user's password
   * @return {Object} A boolean for if there is a match and the original user instance
   */
  async comparePassword(instance, password) {
    const user = await this.knex().where({ uid: instance.uid }).first().select('password');

    return this.argon2.verify(user.password, password)
      .then(isMatch => ({ isMatch, user: instance }));
  }

  /**
   * Determines if an account has been locked due to failed login attempts
   *
   * @param {Object} instance - A user model instance
   * @return {Object} If the account is locked and the user {locked, user}
   */
  checkForLockedAccount(instance) {
    if (config.auth.lockable === false) return { locked: false, user: null };
    if (instance.account_locked) return { locked: true, user: null };

    if (instance.login_attempts === config.auth.lockable.maxAttempts) {
      return this
        .knex()
        .where({ uid: instance.uid })
        .update({
          account_locked: true,
          unlock_account_token: md5(instance.email + Math.random()),
          unlock_account_expires: addMinutes(
            new Date(),
            config.auth.tokens.unlockAccount.expireTime,
          ),
        })
        .then(() =>
          this
            .knex()
            .where({ uid: instance.uid })
            .first()
            .then(lockedAccount => ({ locked: true, user: lockedAccount })));
    }

    return { locked: false, user: instance };
  }

  /**
   * Validate user input
   *
   * @param {Object} attributes - User input from req.body
   * @return {Object} Failed validations
   */
  validate(attributes) {
    return new Promise(resolve => resolve(
      validator(this.name, attributes, this.validations)),
    );
  }

  /**
   * Format user input
   *
   * @param {Object} attributes - An object of key, value pairs
   * @return {Object} A new object with formatted values
   */
  format(attributes) {
    const result = {};

    Object.keys(attributes).forEach((value) => {
      if (this.formatters[value]) {
        result[value] = this.formatters[value](attributes[value]);
      } else {
        result[value] = attributes[value];
      }
    });

    return new Promise(resolve => resolve(result));
  }

  /**
   * Gets the Role ID for the given role
   *
   * @param {String} role - The name of a role
   * @return {String} A role ID.
   */
  _getRole(role) {
    return this.knex('roles').where('role', role).first().select('id');
  }
}

module.exports = User;
